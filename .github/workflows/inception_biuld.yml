name: Inception CI

on:
  push:
    branches: [ main ]
    paths:
      - 'srcs/**'
      - 'docker-compose.yml'
      - '.github/workflows/inception_biuld.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'srcs/**'
      - 'docker-compose.yml'
      - '.github/workflows/inception_biuld.yml'

concurrency:
  group: nginx-${{ github.ref }}
  cancel-in-progress: true

jobs:
  nginx-only:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    env:
      COMPOSE_FILE: docker-compose.yml

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set nginx
        run: |
          docker compose build mariadb nginx wordpress

      - name: Start containers
        run: |
          docker compose up -d mariadb nginx wordpress

      - name: List containers
        run: |
            docker ps --format "table {{.ID}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"

      - name: Aguardar MariaDB pronto (mysqladmin ping)
        run: |
          set -e
          # Tenta obter do ambiente do container (via env_file); se não, cai pro .env local
          ROOT_PASS="$(docker exec mariadb printenv MYSQL_ROOT_PASSWORD 2>/dev/null || true)"
          if [ -z "$ROOT_PASS" ]; then
            ROOT_PASS="$(grep -E '^MYSQL_ROOT_PASSWORD=' .env | cut -d= -f2-)"
          fi

          ATTEMPTS=40
          SLEEP=3
          echo "Aguardando MariaDB responder ao mysqladmin ping..."
          for i in $(seq 1 "$ATTEMPTS"); do
            if docker exec mariadb sh -c "mysqladmin ping -h 127.0.0.1 -uroot -p\"${ROOT_PASS}\" --silent"; then
              echo "MariaDB pronto."
              exit 0
            fi
            echo "Tentativa $i/$ATTEMPTS..."
            sleep "$SLEEP"
          done
          echo "Falha: MariaDB não ficou pronto a tempo."
          docker compose logs mariadb || true
          exit 1

      - name: Validar DB e usuário no MariaDB
        run: |
          set -e
          set -a; source .env; set +a
          docker exec mariadb sh -c "mysql -uroot -p$MYSQL_ROOT_PASSWORD -e \"SHOW DATABASES LIKE '$MYSQL_DATABASE';\" | grep -q $MYSQL_DATABASE"
          docker exec mariadb sh -c "mysql -uroot -p$MYSQL_ROOT_PASSWORD -e \"SELECT User FROM mysql.user WHERE User='$MYSQL_USER';\" | grep -q $MYSQL_USER"
          echo "DB e usuário existem."

      - name: Testar conexão ao MariaDB a partir do wordpress
        run: |
          set -e
          set -a; source .env; set +a
          docker exec wordpress sh -c "mysql -h mariadb -u$MYSQL_USER -p$MYSQL_PASSWORD -e 'SELECT 1' $MYSQL_DATABASE"

      - name: Aguardar php-fpm (porta 9000 no container wordpress)
        run: |
          set -e
          ATTEMPTS=10
          SLEEP=3
          echo "Aguardando php-fpm (wordpress:9000) ..."
          for i in $(seq 1 $ATTEMPTS); do
            if docker exec wordpress sh -c "ss -tlpn 2>/dev/null | grep -q ':9000'"; then
              echo "php-fpm ouvindo na porta 9000."
              exit 0
            fi
            echo "Tentativa $i/$ATTEMPTS - ainda não escutando."
            sleep $SLEEP
          done
          echo "Falha: php-fpm não escutou na porta 9000 a tempo."
          docker compose logs wordpress || true
          exit 1

      - name: Validar php-fpm config
        run: |
          set -e
          docker exec wordpress sh -c "php-fpm -t || php-fpm8.2 -t"

      - name: Test Port 443 (HTTPS)
        run: |
          set -e
          ATTEMPTS=25
          SLEEP=3
          echo "Aguardando HTTPS em https://localhost ..."
          for i in $(seq 1 $ATTEMPTS); do
            CODE=$(curl -sk -o /dev/null -w '%{http_code}' https://localhost/ || true)
            if echo "$CODE" | grep -Eq '^(200|301|302)$'; then
              echo "OK: HTTP $CODE"
              exit 0
            fi
            echo "Tentativa $i/$ATTEMPTS código=$CODE"
            docker compose ps nginx
            sleep $SLEEP
          done
          echo "FALHA: não obteve resposta aceitável."
          docker compose logs nginx || true
          docker exec nginx ss -tlpn || true
          exit 1

      - name: Verificar processo e porta dentro do container
        run: |
          docker exec nginx ss -tlpn
          docker exec nginx nginx -t

      - name: Logs (sucesso)
        if: success()
        run: docker compose logs --no-color nginx

      - name: Teardown
        if: always()
        run: docker compose down -v
